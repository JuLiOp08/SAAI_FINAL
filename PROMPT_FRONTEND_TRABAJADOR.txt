# PROMPT PARA IA - FRONTEND SAAI TRABAJADOR (React Web)

## üéØ CONTEXTO DEL PROYECTO

Estoy desarrollando una aplicaci√≥n web React para **TRABAJADORES DE TIENDA** del sistema SAAI (Smart Assistant for Inventory). Esta es 1 de 3 aplicaciones del ecosistema.

**Rol del usuario:** TRABAJADOR/WORKER
- Permisos: Gesti√≥n de productos, registro de ventas, consulta de notificaciones
- Sin acceso a: Gastos, anal√≠tica, reportes, usuarios, predicciones ML

**Backend:** AWS Serverless (API Gateway + Lambda + DynamoDB)
- Autenticaci√≥n: JWT (Bearer token) - el token se env√≠a en CADA request
- Multi-tenant: Cada trabajador pertenece a UNA tienda (tenant_id extra√≠do del JWT por el backend)
- WebSockets: Notificaciones en tiempo real

**Frontend:** React + Vite + Tailwind CSS
- Tailwind CSS para estilos (ya configurado en package.json)
- React Router para navegaci√≥n
- Axios para llamadas API
- Context API para estado global

---

## üìö ARCHIVOS DE REFERENCIA OBLIGATORIOS

**IMPORTANTE:** Antes de escribir cualquier c√≥digo, debes leer y entender completamente estos documentos:

### 1. SAAI_oficial.txt
- **Secci√≥n cr√≠tica:** "2. Arquitectura TRABAJADOR"
  - 2.1 Endpoints (Request/Response) - L√≠neas 82-510
  - 2.2 Lambdas (qu√© hace cada una) - L√≠neas 512-705
- **Convenciones del backend:** L√≠neas 1-80
  - Autenticaci√≥n y JWT
  - Multi-tenant (tenant_id)
  - Modelo DynamoDB (tenant_id + entity_id + data)
  - C√≥digos vs UUIDs (el frontend SOLO usa c√≥digos: T001P001, T001V005, etc.)
  - Fecha/Hora Per√∫ (backend decide timestamps)
  - Paginaci√≥n (limit + next_token)

### 2. SAAI_resumen_tecnico.txt
- Arquitectura general del sistema
- Flujo de autenticaci√≥n
- WebSockets y eventos en tiempo real
- Persistencia y modelo de datos

### 3. SAAI_Backend_Complete.postman_collection.json
- **Usar como referencia para:**
  - Request bodies exactos (estructura JSON)
  - Response esperados (estructura de datos)
  - Headers requeridos (Authorization: Bearer)
  - Variables de colecci√≥n (base_url, tokens, etc.)
- **M√≥dulos relevantes para TRABAJADOR:**
  - 1. AUTH ‚Üí Login Worker
  - 3. PRODUCTOS ‚Üí Crear, Listar, Buscar, Actualizar, Eliminar
  - 4. VENTAS ‚Üí Calcular Monto, Registrar, Listar, Buscar
  - 9. NOTIFICACIONES ‚Üí Listar

---

## üèóÔ∏è ESTRUCTURA DE LA APP

**Revisa la plantilla React + Vite que he creado** antes de empezar. La estructura debe ser:

```
saai-trabajador/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ pages/            # P√°ginas principales (rutas)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LoginPage.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ productos/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductosPage.jsx          # Lista + crear
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EditarProductoPage.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ BuscarProductosPage.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ventas/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RegistrarVentaPage.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VentasPage.jsx             # Lista + buscar
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ BuscarVentasPage.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ notificaciones/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ NotificacionesPage.jsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ HomePage.jsx                   # Dashboard simple
‚îÇ   ‚îú‚îÄ‚îÄ components/       # Componentes reutilizables
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Navbar.jsx                 # Navegaci√≥n superior
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Sidebar.jsx                # Men√∫ lateral
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Layout.jsx                 # Wrapper con Navbar + Sidebar
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/                            # Componentes UI base
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.jsx                 # Bot√≥n con Tailwind
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Input.jsx                  # Input con Tailwind
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Modal.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Table.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Card.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Badge.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SearchBar.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Spinner.jsx                # Loading spinner
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ productos/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductCard.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductForm.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProductTable.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ventas/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VentaCard.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VentaForm.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CarritoVenta.jsx           # Carrito para registrar venta
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ notificaciones/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ NotificationBadge.jsx
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ NotificationList.jsx
‚îÇ   ‚îú‚îÄ‚îÄ services/         # L√≥gica de API y WebSocket
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.js        # Axios instance con interceptors
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.service.js      # Login, logout, token management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ productos.service.js # CRUD productos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ventas.service.js    # Registrar/listar ventas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ websocket.service.js # WebSocket connection
‚îÇ   ‚îú‚îÄ‚îÄ context/          # Estado global (Context API)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuthContext.jsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ NotificationContext.jsx
‚îÇ   ‚îú‚îÄ‚îÄ hooks/            # Custom hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useAuth.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useWebSocket.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ usePagination.js
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ constants.js  # API_URL, categor√≠as, m√©todos pago
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ helpers.js    # Formateo de fecha, moneda, validaciones
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AppRoutes.jsx # Rutas protegidas (requieren auth)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProtectedRoute.jsx # HOC para rutas privadas
‚îÇ   ‚îî‚îÄ‚îÄ App.jsx           # Router + AuthProvider
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ package.json          # Incluye Tailwind CSS v4.x
‚îú‚îÄ‚îÄ vite.config.js        # Con @tailwindcss/vite plugin
‚îî‚îÄ‚îÄ tailwind.config.js    # OPCIONAL: Solo si se necesita personalizaci√≥n extra (v4 no lo requiere por defecto)
```

---

## üöÄ ORDEN DE IMPLEMENTACI√ìN SUGERIDO

### FASE 1: Autenticaci√≥n y Navegaci√≥n (COMENZAR AQU√ç)
1. **LoginPage** 
   - POST /login con email + password
   - Guardar token en localStorage (NO AsyncStorage, esto es web)
   - **IMPORTANTE:** El tenant_id NO se guarda manualmente, el backend lo extrae del JWT autom√°ticamente
   - Extraer codigo_usuario del response para mostrar en UI
   - Navegaci√≥n a HomePage despu√©s de login exitoso
   - UI con Tailwind: formulario centrado, card con sombra, bot√≥n primary

2. **AuthContext**
   - Estado global: { user, token, isAuthenticated }
   - **NO guardes tenant_id** en estado (el backend lo maneja desde el JWT)
   - Funciones: login(), logout(), checkAuth()
   - Persistencia de sesi√≥n (localStorage)
   - Inicializar token desde localStorage al cargar app

3. **API Service (api.js)**
   - Axios instance con baseURL
   - Interceptor request: agregar Authorization: Bearer {token} desde localStorage
   - Interceptor response: manejar errores 401 ‚Üí logout autom√°tico + redirect a /login
   - Mantener el response completo (no aplanar data.data autom√°ticamente). Usar helper opcional getData(res) si es necesario para acceder a res.data.data

### FASE 2: Productos (Core Functionality)
4. **ProductosPage**
   - GET /productos con paginaci√≥n (limit + next_token)
   - Tabla con Tailwind (o grid de cards)
   - Bot√≥n "Crear Producto" abre modal o navega a formulario
   - Mostrar: c√≥digo, nombre, precio, stock, categor√≠a, acciones (editar/eliminar)
   - Infinite scroll o bot√≥n "Cargar m√°s" para next_token
   - **IMPORTANTE:** El tenant_id NO se env√≠a en la request, el backend lo extrae del JWT

5. **Formulario Crear Producto** (modal o p√°gina separada)
   - Campos: nombre, precio, stock, categor√≠a, descripci√≥n
   - POST /productos (body NO incluye tenant_id, el backend lo agrega autom√°ticamente)
   - Validaciones: precio > 0, stock >= 0, nombre requerido
   - Categor√≠as fijas: bebidas, snacks, abarrotes, limpieza, otros (select con Tailwind)
   - UI Tailwind: formulario con labels, inputs estilizados, botones primary/secondary

6. **BuscarProductosPage**
   - POST /productos/buscar con query
   - SearchBar con debounce
   - B√∫squeda por: nombre, c√≥digo, categor√≠a

7. **EditarProductoPage**
   - PUT /productos/{codigo_producto}
   - Pre-fill del formulario con datos actuales
   - Solo editar: precio, stock, descripci√≥n (nombre y categor√≠a no se cambian)

### FASE 3: Ventas (Critical Feature)
8. **RegistrarVentaPage**
   - Selector de productos (m√∫ltiple)
   - Cantidad por producto
   - POST /ventas/calcular (preview del total SIN guardar)
   - POST /ventas (registrar venta final)
   - Selector de m√©todo de pago: efectivo, tarjeta, yape
   - Mostrar total calculado antes de confirmar

9. **ListaVentasPage**
   - GET /ventas con paginaci√≥n
   - Mostrar: c√≥digo, fecha, cliente, total, m√©todo pago
   - Filtros: fecha (hoy, esta semana, este mes)

10. **BuscarVentasPage**
    - POST /ventas/buscar
    - B√∫squeda por: c√≥digo, fecha, m√©todo de pago, producto vendido

### FASE 4: Notificaciones y WebSocket
11. **NotificacionesPage**
    - GET /notificacion con paginaci√≥n
    - Lista de alertas del sistema
    - Badge con contador de no le√≠das

12. **WebSocket Service**
    - Conectar a WebSocket API al login
    - **IMPORTANTE:** Verificar en SAAI_oficial.txt y Postman el formato EXACTO de conexi√≥n (puede ser ?token=JWT en query string, o en headers, o handshake custom). NO asumir formato sin verificar.
    - Escuchar eventos: venta_registrada, producto_actualizado
    - Actualizar badge de notificaciones

### FASE 5: Pulido y UX
13. **Mejoras generales**
    - Loading states (spinner de Tailwind o biblioteca como react-loader-spinner)
    - Error handling (react-hot-toast para mensajes)
    - Validaciones de formularios
    - Confirmaciones antes de eliminar (di√°logo personalizado o biblioteca como react-modal)
    - Bot√≥n "Cargar m√°s" o infinite scroll en listas paginadas
    - Web Notifications API (opcional, si el usuario da permiso del navegador)

---

## üí° TIPS IMPORTANTES

### 1. Autenticaci√≥n y Multi-tenant
```javascript
// ‚úÖ CORRECTO: El token se guarda en localStorage (web)
const login = async (email, password) => {
  const response = await api.post('/login', { email, password });
  const { token, user } = response.data.data;
  
  // Guardar en localStorage (NO AsyncStorage)
  localStorage.setItem('token', token);
  localStorage.setItem('user', JSON.stringify(user));
  
  setAuthState({ token, user, isAuthenticated: true });
  
  // ‚ùå NO HACER ESTO: NO guardes tenant_id manualmente
  // localStorage.setItem('tenant_id', user.tenant_id); // ‚ùå INCORRECTO
  
  // El tenant_id est√° en el JWT, el BACKEND lo extrae autom√°ticamente
};

// ‚úÖ CORRECTO: Axios interceptor agrega el token autom√°ticamente
api.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
    // ‚ùå NO agregues tenant_id manualmente en headers
  }
  return config;
});

// ‚ö†Ô∏è REGLA CR√çTICA: NO INVENTAR ENDPOINTS
// Si necesitas un endpoint que no est√° en SAAI_oficial.txt o Postman:
// 1. Verificar que realmente no existe
// 2. Preguntar al usuario o marcarlo como TODO
// 3. NO crear rutas nuevas sin confirmaci√≥n
// Ejemplo: ‚ùå NO HACER: await api.post('/productos/validar') // Este endpoint NO existe

// ‚úÖ CORRECTO: Manejar 401 (token expirado)
api.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      
      // ‚úÖ PREFERIR: React Router navigate (si est√° disponible)
      // Si tienes acceso al navigate de useNavigate(), usarlo:
      // navigate('/login');
      
      // ‚úÖ FALLBACK: window.location (solo si no hay router disponible)
      window.location.href = '/login';
      
      // Nota: Para usar navigate en interceptor, crear una instancia global
      // o usar un event emitter para comunicar con el componente de routing
    }
    return Promise.reject(error);
  }
);
```

### 2. C√≥digos vs UUIDs
```javascript
// ‚ùå INCORRECTO: Nunca uses UUID
const eliminar = (uuid) => api.delete(`/productos/${uuid}`);

// ‚úÖ CORRECTO: Usa siempre c√≥digos (T001P001, T001V005, etc.)
const eliminar = (codigo_producto) => api.delete(`/productos/${codigo_producto}`);
```

### 3. Paginaci√≥n
```javascript
const [productos, setProductos] = useState([]);
const [nextToken, setNextToken] = useState(null);

const fetchProductos = async () => {
  const params = { limit: 20 };
  if (nextToken) params.next_token = nextToken;
  
  const response = await api.get('/productos', { params });
  // ‚úÖ FORMA SEGURA: usar prev para evitar bugs de estado
  setProductos(prev => [...prev, ...response.data.data.productos]);
  setNextToken(response.data.data.next_token || null);
};
```

### 4. Fecha/Hora
```javascript
// ‚ùå INCORRECTO: No env√≠es fecha/hora desde el frontend
const venta = {
  productos: [...],
  fecha: new Date().toISOString() // ‚ùå NO HACER ESTO
};

// ‚úÖ CORRECTO: El backend genera la fecha autom√°ticamente
const venta = {
  productos: [...],
  metodo_pago: 'efectivo'
  // fecha NO se env√≠a
};
```

### 5. WebSockets (Notificaciones en Tiempo Real)

**FORMATO OFICIAL (VERIFICADO EN SAAI_oficial.txt):**
- Autenticaci√≥n: `?token=${token}` en query string
- El token se obtiene de localStorage (SIN "Bearer " prefix)
- Estructura de eventos: `{ event_type: string, payload: object }`

**EVENTOS DISPONIBLES (ROL TRABAJADOR):**
1. `venta_registrada` ‚Üí emitido por RegistrarVenta
   - Refetch: ventas, productos (stock actualizado), notificaciones
2. `producto_actualizado` ‚Üí emitido por ActualizarProducto
   - Refetch: productos
3. `analitica_actualizada` ‚Üí emitido por ActualizarAnalitica (cada 4h)
   - Refetch: notificaciones (nuevas alertas detectadas)

```javascript
// websocket.service.js
let wsInstance = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_DELAY = 5000;

export const connectWebSocket = (token, callbacks = {}) => {
  // Obtener URL de WebSocket desde .env
  const WS_URL = import.meta.env.VITE_WS_URL;
  if (!WS_URL) {
    console.error('‚ùå VITE_WS_URL no configurado en .env');
    return null;
  }

  // Token limpio (SIN "Bearer ")
  const cleanToken = token.replace('Bearer ', '');
  
  // Formato oficial: ?token=JWT
  const wsUrl = `${WS_URL}?token=${cleanToken}`;
  
  try {
    wsInstance = new WebSocket(wsUrl);
    
    wsInstance.onopen = () => {
      console.log('‚úÖ WebSocket conectado');
      reconnectAttempts = 0; // Reset contador
      callbacks.onOpen?.();
    };
    
    wsInstance.onmessage = (event) => {
      try {
        // Estructura oficial: { event_type: string, payload: object }
        const data = JSON.parse(event.data);
        const { event_type, payload } = data;
        
        console.log(`üì© Evento WebSocket: ${event_type}`, payload);
        
        // Manejar eventos seg√∫n tipo
        switch (event_type) {
          case 'venta_registrada':
            // Mostrar notificaci√≥n browser
            if (Notification.permission === 'granted') {
              new Notification('Nueva venta registrada', {
                body: `Venta ${payload.codigo_venta} por S/ ${payload.total}`,
                icon: '/favicon.ico',
                tag: 'venta' // Evita duplicados
              });
            }
            // Refetch datos
            callbacks.onVentaRegistrada?.(payload);
            break;
            
          case 'producto_actualizado':
            callbacks.onProductoActualizado?.(payload);
            break;
            
          case 'analitica_actualizada':
            // Nuevas alertas disponibles (stock bajo, etc.)
            callbacks.onAnaliticaActualizada?.(payload);
            break;
            
          default:
            console.warn(`Evento no manejado: ${event_type}`);
        }
        
        // Callback gen√©rico
        callbacks.onMessage?.(data);
        
      } catch (error) {
        console.error('‚ùå Error parseando mensaje WebSocket:', error);
      }
    };
    
    wsInstance.onerror = (error) => {
      console.error('‚ùå WebSocket error:', error);
      callbacks.onError?.(error);
    };
    
    wsInstance.onclose = (event) => {
      console.log('WebSocket cerrado:', event.code, event.reason);
      
      // C√≥digos de cierre: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
      const isAuthError = 
        event.code === 1008 || // Policy Violation
        event.code === 4001 || // Custom: Unauthorized
        event.reason?.toLowerCase().includes('401') ||
        event.reason?.toLowerCase().includes('unauthorized');
      
      if (isAuthError) {
        console.error('‚ùå Token inv√°lido/expirado - cerrando sesi√≥n');
        localStorage.removeItem('token');
        localStorage.removeItem('user');
        window.location.href = '/login';
        return; // NO reconectar
      }
      
      // Reconectar solo si no alcanz√≥ el l√≠mite
      if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
        reconnectAttempts++;
        console.log(`‚Üª Reconectando (intento ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
        setTimeout(() => {
          connectWebSocket(token, callbacks);
        }, RECONNECT_DELAY);
      } else {
        console.error('‚ùå M√°ximo de intentos de reconexi√≥n alcanzado');
        callbacks.onMaxReconnectReached?.();
      }
    };
    
    return wsInstance;
    
  } catch (error) {
    console.error('‚ùå Error creando WebSocket:', error);
    return null;
  }
};

export const disconnectWebSocket = () => {
  if (wsInstance && wsInstance.readyState === WebSocket.OPEN) {
    wsInstance.close(1000, 'Client disconnect'); // Cierre normal
    wsInstance = null;
  }
};

export const getWebSocketState = () => {
  if (!wsInstance) return 'CLOSED';
  const states = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
  return states[wsInstance.readyState];
};
```

**USO EN COMPONENTE (App.jsx o AuthContext - NIVEL M√ÅS ALTO):**

‚ö†Ô∏è **CR√çTICO:** El WebSocket debe conectarse **UNA SOLA VEZ** al iniciar sesi√≥n y mantenerse abierto durante TODA la sesi√≥n. **NO reconectar** al cambiar de p√°gina (productos ‚Üí ventas ‚Üí notificaciones).

‚úÖ **CORRECTO:** Implementar en **App.jsx** o **AuthContext** (componente ra√≠z)  
‚ùå **INCORRECTO:** Implementar en p√°ginas individuales (ProductosPage, VentasPage) - causar√° reconexiones innecesarias

```javascript
// App.jsx o AuthContext (NIVEL M√ÅS ALTO, NO EN P√ÅGINAS)
import { connectWebSocket, disconnectWebSocket } from './services/websocket.service';

useEffect(() => {
  const token = localStorage.getItem('token');
  if (!token) return;
  
  // Solicitar permisos de notificaciones
  if (Notification.permission === 'default') {
    Notification.requestPermission();
  }
  
  // Conectar WebSocket UNA SOLA VEZ al iniciar sesi√≥n
  const ws = connectWebSocket(token, {
    onVentaRegistrada: (payload) => {
      // Refetch ventas y productos
      queryClient.invalidateQueries(['ventas']);
      queryClient.invalidateQueries(['productos']);
      queryClient.invalidateQueries(['notificaciones']);
    },
    onProductoActualizado: (payload) => {
      queryClient.invalidateQueries(['productos']);
    },
    onAnaliticaActualizada: (payload) => {
      // Nuevas alertas detectadas
      queryClient.invalidateQueries(['notificaciones']);
    }
  });
  
  // Cleanup solo al desmontar App (logout o cerrar app)
  return () => {
    disconnectWebSocket();
  };
}, [token]); // Se ejecuta solo cuando cambia el token (login/logout)

// CR√çTICO: Cleanup al cerrar navegador/pesta√±a
useEffect(() => {
  const handleBeforeUnload = () => {
    disconnectWebSocket();
  };
  
  window.addEventListener('beforeunload', handleBeforeUnload);
  
  return () => {
    window.removeEventListener('beforeunload', handleBeforeUnload);
  };
}, []);
```

**VERIFICACI√ìN (DevTools Console):**
- Al hacer login ‚Üí ver `‚úÖ WebSocket conectado` (1 vez)
- Al navegar (productos ‚Üí ventas ‚Üí notificaciones) ‚Üí NO debe reconectar
- Al hacer logout ‚Üí ver `WebSocket cerrado`
- Si ves m√∫ltiples `‚úÖ WebSocket conectado` al cambiar de p√°gina ‚Üí est√° mal implementado

**CONFIGURACI√ìN .env:**
```bash
VITE_WS_URL=wss://xxx.execute-api.us-east-1.amazonaws.com/dev
```

### 6. Validaciones
```javascript
// Validar antes de enviar al backend
const validarProducto = (data) => {
  const errors = {};
  
  if (!data.nombre || data.nombre.trim() === '') {
    errors.nombre = 'Nombre es requerido';
  }
  if (!data.precio || data.precio <= 0) {
    errors.precio = 'Precio debe ser mayor a 0';
  }
  if (data.stock === '' || data.stock === null || data.stock === undefined || data.stock < 0) {
    errors.stock = 'Stock no puede ser negativo';
  }
  
  return Object.keys(errors).length === 0 ? null : errors;
};
```

### 7. Error Handling
```javascript
// Manejar errores de API consistentemente
try {
  const response = await api.post('/productos', data);
  toast.success('Producto creado correctamente');
  navigate(-1); // o navigate('/productos')
} catch (error) {
  const mensaje = error.response?.data?.message || 'Error al crear producto';
  toast.error(mensaje);
}
```

---

## üì± FEATURES ESPEC√çFICAS TRABAJADOR

### Productos
- ‚úÖ Crear, editar, eliminar, listar, buscar
- ‚úÖ Categor√≠as predefinidas (no custom)
- ‚úÖ Stock siempre >= 0
- ‚úÖ Precio siempre > 0

### Ventas
- ‚úÖ Calcular total ANTES de registrar (POST /ventas/calcular)
- ‚úÖ Descuento de stock autom√°tico (backend)
- ‚úÖ M√©todos de pago: efectivo, tarjeta, yape
- ‚úÖ Cliente opcional (default: "Cliente General")
- ‚úÖ No se pueden editar ni eliminar ventas (solo listar/buscar)

### Notificaciones
- ‚úÖ Solo lectura (generadas por backend)
- ‚úÖ Tipos: stock_bajo, venta_registrada, producto_actualizado
- ‚úÖ Badge con contador de no le√≠das
- ‚úÖ WebSocket para notificaciones en tiempo real

### Restricciones
- ‚ùå Sin acceso a gastos
- ‚ùå Sin acceso a anal√≠tica
- ‚ùå Sin acceso a reportes
- ‚ùå Sin acceso a gesti√≥n de usuarios
- ‚ùå Sin acceso a predicciones ML

---

## üé® UI/UX RECOMENDACIONES CON TAILWIND CSS

1. **Colores (Tailwind):** 
   - Primary: `bg-blue-600 hover:bg-blue-700 text-white`
   - Success: `bg-green-600 hover:bg-green-700 text-white`
   - Danger: `bg-red-600 hover:bg-red-700 text-white`
   - Warning: `bg-yellow-500 hover:bg-yellow-600 text-white`
   
2. **Layout:**
   - Navbar superior con logo, nombre de tienda, notificaciones, logout
   - Sidebar izquierdo (desktop) o men√∫ hamburguesa (mobile) con:
     - üè† Inicio (Dashboard simple)
     - üì¶ Productos (Gesti√≥n completa)
     - üí∞ Ventas (Registrar + historial)
     - üîî Notificaciones
   - Contenido principal con padding: `<main className="p-6">`
   
3. **Componentes UI con Tailwind:**
   ```jsx
   // Button.jsx
   <button className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
     {children}
   </button>
   
   // Input.jsx
   <input className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
   
   // Card.jsx
   <div className="bg-white rounded-lg shadow-md p-6">
     {children}
   </div>
   
   // Table.jsx
   <table className="min-w-full divide-y divide-gray-200">
     <thead className="bg-gray-50">
       <tr>
         <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
           C√≥digo
         </th>
       </tr>
     </thead>
   </table>
   ```

4. **Icons:** Heroicons (ya compatible con Tailwind) o React Icons
   ```bash
   npm install @heroicons/react
   ```
   
5. **Forms:** React Hook Form para validaciones
   ```bash
   npm install react-hook-form
   ```
   
6. **Toasts:** react-hot-toast (ligero y compatible con Tailwind)
   ```bash
   npm install react-hot-toast
   ```
   
7. **Loading:** Spinner con Tailwind
   ```jsx
   <div className="flex items-center justify-center">
     <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
   </div>
   ```
   
8. **Empty States:** Centrados con Tailwind
   ```jsx
   <div className="flex flex-col items-center justify-center h-64 text-gray-500">
     <svg className="w-16 h-16 mb-4" />  
     <p className="text-lg">No hay productos registrados</p>
     <button className="mt-4 px-4 py-2 bg-blue-600 text-white rounded-lg">
       Crear Producto
     </button>
   </div>
   ```

9. **Responsive:** Usar clases responsive de Tailwind
   ```jsx
   <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
     {/* Cards de productos */}
   </div>
   ```

10. **Dark Mode (opcional):** Tailwind soporta dark mode out-of-the-box
    ```jsx
    <div className="bg-white dark:bg-gray-800 text-gray-900 dark:text-white">
    ```

---

## ‚ö†Ô∏è ERRORES COMUNES A EVITAR

1. **NO uses UUIDs**, solo c√≥digos (T001P001, T001V005)
2. **NO env√≠es fecha/hora** desde frontend (el backend decide)
3. **NO calcules totales** en frontend (usa POST /ventas/calcular)
4. **NO guardes tenant_id** manualmente (sale del JWT autom√°ticamente)
5. **NO permitas stock negativo** en formularios
6. **NO permitas editar/eliminar ventas** (solo productos)
7. **NO llames a ActualizarAnalitica** (es solo EventBridge)
8. **NO uses HTTP en producci√≥n** (solo HTTPS para WebSockets)

---

## üîß CONFIGURACI√ìN INICIAL

```javascript
// src/utils/constants.js
export const API_URL = import.meta.env.VITE_API_URL || 'https://xxx.execute-api.us-east-1.amazonaws.com/dev';
export const WS_URL = import.meta.env.VITE_WS_URL || 'wss://xxx.execute-api.us-east-1.amazonaws.com/dev';

export const CATEGORIAS = [
  'bebidas',
  'snacks',
  'abarrotes',
  'limpieza',
  'otros'
];

export const METODOS_PAGO = [
  'efectivo',
  'tarjeta',
  'yape'
];

// Estados permitidos (referencia, el backend maneja la l√≥gica)
export const ESTADOS = {
  ACTIVO: 'ACTIVO',
  INACTIVO: 'INACTIVO'
};
```

```javascript
// .env.local (crear este archivo)
VITE_API_URL=https://xxx.execute-api.us-east-1.amazonaws.com/dev
VITE_WS_URL=wss://xxx.execute-api.us-east-1.amazonaws.com/dev
```

```javascript
// TAILWIND CSS v4 CON VITE
// Con Tailwind v4.x + @tailwindcss/vite, NO es necesario tailwind.config.js
// La configuraci√≥n se hace en CSS con @theme y @config

// Si A√öN se requiere tailwind.config.js (casos especiales):
// Y el proyecto usa "type": "module" (ESM), usar export default:
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#eff6ff',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8',
        },
      },
    },
  },
  plugins: [],
}
```

---

## ‚úÖ CHECKLIST DE IMPLEMENTACI√ìN

Usa este checklist para trackear progreso:

- [ ] LoginPage + AuthContext
- [ ] API Service con interceptors
- [ ] Navegaci√≥n principal (React Router con Sidebar o Navbar)
- [ ] ListaProductosPage con paginaci√≥n
- [ ] CrearProductoPage con validaciones
- [ ] EditarProductoPage
- [ ] BuscarProductosPage
- [ ] RegistrarVentaPage con c√°lculo previo
- [ ] ListaVentasPage
- [ ] BuscarVentasPage
- [ ] NotificacionesPage
- [ ] WebSocket service
- [ ] Error handling global (react-hot-toast)
- [ ] Loading states (spinners Tailwind)
- [ ] Infinite scroll o bot√≥n Cargar m√°s
- [ ] Testing en navegador (Chrome DevTools, responsive mode)

---

## üö¶ COMENZAR AHORA

**Primer paso:** Lee SAAI_oficial.txt secci√≥n "2. Arquitectura TRABAJADOR" completa.

**Segundo paso:** Revisa la estructura de carpetas de la plantilla React + Vite con Tailwind CSS.

**Tercer paso:** Implementa LoginPage + AuthContext (FASE 1.1 y 1.2).

**Pregunta antes de continuar:** ¬øEntendiste el flujo de autenticaci√≥n y c√≥mo se usa el JWT en todas las requests?

---

## üîß TROUBLESHOOTING - ERRORES COMUNES

### Error 403 en endpoints protegidos (GET /notificacion, etc.)

**S√≠ntomas:**
- Error: `403 Forbidden`
- CORS bloqueado (no hay header 'Access-Control-Allow-Origin')
- El token JWT est√° correctamente en el header `Authorization: Bearer <token>`

**Causa ra√≠z:**
El Lambda Authorizer est√° rechazando la solicitud ANTES de que llegue al Lambda del endpoint.
Cuando el Authorizer retorna `Deny`, API Gateway responde con 403 y NO incluye headers CORS.

**Diagn√≥stico paso a paso:**

1. **Verificar token en el frontend:**
```javascript
// En el navegador console (DevTools):
const token = localStorage.getItem('token');
console.log('Token:', token);

// Decodificar JWT (sin verificar firma):
const payload = JSON.parse(atob(token.split('.')[1]));
console.log('Payload:', payload);

// Verificar claims requeridos:
console.log('codigo_usuario:', payload.codigo_usuario); // Debe existir
console.log('tenant_id:', payload.tenant_id);         // Debe existir
console.log('rol:', payload.rol);                     // Debe ser TRABAJADOR/ADMIN/SAAI
console.log('exp:', new Date(payload.exp * 1000));    // Debe ser futuro
```

2. **Verificar que el token no est√© expirado:**
```javascript
const isExpired = payload.exp * 1000 < Date.now();
console.log('Token expirado:', isExpired);
if (isExpired) {
  console.error('‚ö†Ô∏è Token expirado, hacer logout y login nuevamente');
  localStorage.clear();
  window.location.href = '/login';
}
```

3. **Verificar estructura del request:**
```javascript
// En axios interceptor, verificar que se env√≠a correctamente:
api.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  console.log('üîë Token enviado:', token ? 'S√≠' : 'No');
  console.log('üìù Header Authorization:', config.headers.Authorization);
  return config;
});
```

**Soluciones en orden de prioridad:**

**A) Token expirado ‚Üí Hacer login nuevamente**
```javascript
// En el interceptor de respuesta:
api.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 403 || error.response?.status === 401) {
      console.error('‚ö†Ô∏è Token inv√°lido/expirado - redirigiendo a login');
      localStorage.clear();
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

**B) Claims faltantes ‚Üí Problema en el backend al generar JWT**
- Verificar que el endpoint `/login` retorna un JWT v√°lido con todos los claims
- El backend debe incluir: `codigo_usuario`, `tenant_id`, `rol`

**C) Token no registrado en tabla de tokens ‚Üí Hacer login nuevamente**
- El Authorizer verifica que el token exista en la tabla correspondiente
- Si hiciste login en otro dispositivo, el token anterior puede estar invalidado

**D) Configuraci√≥n del Authorizer en serverless.yml (problema backend)**
- Si TODOS los tokens fallan con 403, el problema est√° en la configuraci√≥n
- Verificar que el authorizer est√© correctamente desplegado
- Ejecutar `sls deploy` nuevamente

**Verificaci√≥n final (despu√©s de login nuevo):**
```javascript
// Probar endpoint:
const testAuth = async () => {
  try {
    const response = await api.get('/notificacion?limit=5');
    console.log('‚úÖ Auth OK:', response.data);
  } catch (error) {
    console.error('‚ùå Auth fall√≥:', error.response?.status, error.response?.data);
  }
};

testAuth();
```

**Nota importante:**
Si el error persiste despu√©s de login nuevo con token v√°lido:
1. Verificar en AWS CloudWatch Logs del Lambda `authorizer`
2. Buscar logs con el `codigo_usuario` del token
3. Identificar cu√°l validaci√≥n est√° fallando

---

¬°Empecemos! Dime cuando hayas le√≠do los archivos de referencia y est√©s listo para implementar el LoginPage.
